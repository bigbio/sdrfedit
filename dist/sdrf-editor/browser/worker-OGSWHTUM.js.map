{
  "version": 3,
  "sources": ["src/app/workers/pyodide.worker.ts"],
  "sourcesContent": ["/// <reference lib=\"webworker\" />\n\n/**\n * Pyodide Web Worker\n *\n * Runs Python code in a separate thread to avoid blocking the UI.\n * Used for sdrf-pipelines validation.\n */\n\nlet pyodide: any = null;\nlet sdrfPipelinesLoaded = false;\n\n/**\n * Initialize Pyodide and install sdrf-pipelines\n */\nasync function initPyodide(): Promise<void> {\n  postMessage({ type: 'progress', payload: 'Loading Pyodide runtime...' });\n\n  // Load Pyodide from CDN using dynamic import (for module workers)\n  // @ts-ignore - dynamic import from CDN\n  const { loadPyodide: loadPyodideModule } = await import(\n    /* webpackIgnore: true */\n    'https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.mjs'\n  );\n\n  pyodide = await loadPyodideModule({\n    indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.26.4/full/'\n  });\n\n  postMessage({ type: 'progress', payload: 'Installing Python packages...' });\n\n  // Install required packages\n  await pyodide.loadPackage(['micropip', 'numpy', 'pandas']);\n\n  postMessage({ type: 'progress', payload: 'Installing sdrf-pipelines...' });\n\n  // Construct absolute URL for the wheel file\n  // Web Workers need absolute URLs since relative paths resolve from worker location\n  const wheelUrl = new URL('/assets/wheels/sdrf_pipelines-0.0.34.dev-py3-none-any.whl', self.location.origin).href;\n  pyodide.globals.set('wheel_url', wheelUrl);\n\n  // Install sdrf-pipelines from local wheel (dev version with clean dependencies)\n  await pyodide.runPythonAsync(`\nimport micropip\n\n# Install dependencies first\nawait micropip.install([\n    'pyyaml',\n    'click',\n    'defusedxml',\n    'pydantic',\n])\n\n# Install sdrf-pipelines from local wheel using absolute URL\nawait micropip.install(wheel_url)\n\nprint(\"sdrf-pipelines installed successfully\")\n  `);\n\n  sdrfPipelinesLoaded = true;\n  postMessage({ type: 'ready' });\n}\n\n/**\n * Get list of available validation templates\n */\nasync function getTemplates(): Promise<string[]> {\n  if (!sdrfPipelinesLoaded) {\n    throw new Error('Pyodide not initialized');\n  }\n\n  const result = await pyodide.runPythonAsync(`\nimport json\nfrom sdrf_pipelines.sdrf.schemas import SchemaRegistry\n\nregistry = SchemaRegistry()\ntemplates = registry.get_schema_names()\njson.dumps(templates)\n  `);\n\n  return JSON.parse(result);\n}\n\n/**\n * Validate SDRF content against templates\n */\nasync function validate(\n  sdrfTsv: string,\n  templates: string[],\n  skipOntology: boolean = true\n): Promise<any[]> {\n  if (!sdrfPipelinesLoaded) {\n    throw new Error('Pyodide not initialized');\n  }\n\n  // Pass data to Python global scope\n  pyodide.globals.set('sdrf_content', sdrfTsv);\n  pyodide.globals.set('template_names', templates);\n  pyodide.globals.set('skip_ontology', skipOntology);\n\n  const result = await pyodide.runPythonAsync(`\nimport json\nimport logging\nfrom io import StringIO\nfrom sdrf_pipelines.sdrf.sdrf import read_sdrf\nfrom sdrf_pipelines.sdrf.schemas import SchemaRegistry, SchemaValidator\n\n# Parse SDRF from TSV string\nsdrf = read_sdrf(StringIO(sdrf_content))\n\n# Create validator with registry\nregistry = SchemaRegistry()\nvalidator = SchemaValidator(registry)\n\n# Collect all errors from all templates\nall_errors = []\n\nfor template in template_names:\n    try:\n        errors = validator.validate(\n            sdrf,\n            schema_name=template,\n            skip_ontology=skip_ontology,\n            use_ols_cache_only=True\n        )\n        all_errors.extend(errors)\n    except Exception as e:\n        # Add template loading error\n        all_errors.append({\n            'message': f\"Failed to validate with template '{template}': {str(e)}\",\n            'row': -1,\n            'column': None,\n            'value': None,\n            'error_type': logging.ERROR,\n            'suggestion': None\n        })\n\n# Convert errors to JSON-serializable format\nresult = []\nfor err in all_errors:\n    if hasattr(err, 'message'):\n        # It's a LogicError object\n        result.append({\n            'message': err.message,\n            'row': getattr(err, 'row', -1),\n            'column': getattr(err, 'column', None),\n            'value': getattr(err, 'value', None),\n            'level': 'error' if getattr(err, 'error_type', logging.ERROR) == logging.ERROR else 'warning',\n            'suggestion': getattr(err, 'suggestion', None)\n        })\n    elif isinstance(err, dict):\n        # It's already a dict (from our error handling above)\n        result.append({\n            'message': err.get('message', 'Unknown error'),\n            'row': err.get('row', -1),\n            'column': err.get('column'),\n            'value': err.get('value'),\n            'level': 'error' if err.get('error_type', logging.ERROR) == logging.ERROR else 'warning',\n            'suggestion': err.get('suggestion')\n        })\n\njson.dumps(result)\n  `);\n\n  return JSON.parse(result);\n}\n\n/**\n * Get template details (columns, validators)\n */\nasync function getTemplateDetails(templateName: string): Promise<any> {\n  if (!sdrfPipelinesLoaded) {\n    throw new Error('Pyodide not initialized');\n  }\n\n  pyodide.globals.set('template_name', templateName);\n\n  const result = await pyodide.runPythonAsync(`\nimport json\nfrom sdrf_pipelines.sdrf.schemas import SchemaRegistry\n\nregistry = SchemaRegistry()\nschema = registry.get_schema(template_name)\n\nif schema:\n    details = {\n        'name': schema.name,\n        'description': getattr(schema, 'description', ''),\n        'version': getattr(schema, 'version', ''),\n        'extends': getattr(schema, 'extends', None),\n        'columns': []\n    }\n\n    if hasattr(schema, 'columns'):\n        for col_name, col in schema.columns.items() if isinstance(schema.columns, dict) else [(c.name, c) for c in schema.columns]:\n            details['columns'].append({\n                'name': col_name if isinstance(col_name, str) else getattr(col, 'name', ''),\n                'requirement': str(getattr(col, 'requirement', 'optional')),\n                'description': getattr(col, 'description', '')\n            })\n\n    json.dumps(details)\nelse:\n    json.dumps(None)\n  `);\n\n  return JSON.parse(result);\n}\n\n// Handle messages from main thread\naddEventListener('message', async (event) => {\n  const { type, payload, id } = event.data;\n\n  try {\n    switch (type) {\n      case 'init':\n        await initPyodide();\n        break;\n\n      case 'validate':\n        const errors = await validate(\n          payload.sdrf,\n          payload.templates,\n          payload.skipOntology ?? true\n        );\n        postMessage({ type: 'validation-result', payload: errors, id });\n        break;\n\n      case 'get-templates':\n        const templates = await getTemplates();\n        postMessage({ type: 'templates', payload: templates, id });\n        break;\n\n      case 'get-template-details':\n        const details = await getTemplateDetails(payload.template);\n        postMessage({ type: 'template-details', payload: details, id });\n        break;\n\n      default:\n        postMessage({ type: 'error', payload: `Unknown message type: ${type}`, id });\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    postMessage({ type: 'error', payload: errorMessage, id });\n  }\n});\n\n// Signal that worker is loaded (but not initialized)\npostMessage({ type: 'worker-loaded' });\n"],
  "mappings": "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",
  "names": []
}
